{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,S,I,GCAO,IAAM,EAAS,OAAO,MAAM,CAAC,CAChC,gBAAiB,aACjB,mBAAoB,yBACpB,iBAAkB,iBAClB,gBAAiB,sBACrB,E,G,E,Q,S,C,C,C,E,E,E,O,C,kB,I,G,I,E,E,S,E,E,QCDO,OAAM,EAIT,YACqB,CAAgB,CAChB,CAAkB,CAClB,CAAmC,CACnC,CAAgC,CAChC,CAAkC,CAClC,CAAsB,CACtB,CAAuC,CAC1D,CAPmB,IAAA,CAAA,OAAA,CAAA,EACA,IAAA,CAAA,QAAA,CAAA,EACA,IAAA,CAAA,cAAA,CAAA,EACA,IAAA,CAAA,aAAA,CAAA,EACA,IAAA,CAAA,gBAAA,CAAA,EACA,IAAA,CAAA,SAAA,CAAA,EACA,IAAA,CAAA,qBAAA,CAAA,EAVb,IAAA,CAAA,WAAA,CAAsB,EACtB,IAAA,CAAA,UAAA,CAAwB,CAAE,MAAO,EAAG,OAAQ,CAAE,EAoDrC,IAAA,CAAA,qBAAA,CAAwB,AAAC,IACtC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,OAAQ,EAAM,aAAa,CAAsB,KAAK,EACrF,EAEiB,IAAA,CAAA,WAAA,CAAc,KAC3B,IAAM,EAAS,OAAO,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAE7C,CAAA,EAAS,GACT,CAAA,IAAI,CAAC,WAAW,CAAG,CADvB,CAGJ,EAEiB,IAAA,CAAA,WAAA,CAAc,AAAC,IAC5B,IAAM,EAA8B,IAAI,CAAC,cAAc,GAAK,AAAA,EAAA,mBAAkB,CAAE,KAAK,CAC/E,IAAI,CAAC,iCAAiC,CAAC,GACvC,IAAI,CAAC,iCAAiC,CAAC,GAE7C,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EACrB,EA3DI,IAAI,CAAC,YAAY,EACrB,CAEO,gBAAuB,CAC1B,IAAI,EAAS,EACT,EAAc,EAEZ,EAAQ,CAAC,EAAoB,CAAC,IAChC,OAAO,qBAAqB,CAAC,GAE7B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAClC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,IAAI,CAAC,WAAW,CAAE,IAAI,CAAC,UAAU,EAEzE,EAAE,EAEE,EAAY,EAAS,MACrB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAI,AAAA,CAAA,IAAO,EAAe,CAAA,EAAY,CAAA,CAAK,EAAI,OAAO,CAAC,GAC/E,EAAS,EACT,EAAc,EAEtB,EAEA,GACJ,CAEO,eAAsB,CACzB,IAAI,CAAC,aAAa,CAAC,KAAK,CAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CACzD,IAAI,CAAC,aAAa,CAAC,MAAM,CAAG,IAAI,CAAC,aAAa,CAAC,YAAY,CAC1D,IAAI,CAAC,UAAU,CAAG,CACf,MAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CACrC,OAAQ,IAAI,CAAC,aAAa,CAAC,YAAY,AAC3C,EAEA,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,QAAS,IAAI,CAAC,WAAW,EAChE,IAAI,CAAC,WAAW,GAEhB,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,QAAS,IAAI,CAAC,WAAW,EAE7D,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,QAAS,IAAI,CAAC,qBAAqB,CACnF,CAsBQ,kCAAkC,CAAiB,CAAc,CACrE,IAAM,EAAO,IAAI,CAAC,aAAa,CAAC,qBAAqB,GAErD,MAAO,CACH,EAAG,EAAM,OAAO,CAAG,EAAK,IAAI,CAC5B,EAAG,EAAM,OAAO,CAAG,EAAK,GAAG,AAC/B,CACJ,CAEQ,kCAAkC,CAAiB,CAAc,CACpE,IAAM,EAAO,IAAI,CAAC,aAAa,CAAC,qBAAqB,GAGpD,EAAI,EAAM,OAAO,CAAG,EAAK,IAAI,CAC7B,EAAI,EAAM,OAAO,CAAG,EAAK,GAAG,CAG5B,EAAU,EAAI,IAAI,CAAC,aAAa,CAAC,WAAW,CAAG,EAC/C,EAAU,EAAI,IAAI,CAAC,aAAa,CAAC,YAAY,CAAG,EAItD,OAFA,QAAQ,GAAG,CAAC,+BAAgC,EAAS,GAE9C,CACH,EAAG,EACH,EAAG,CACP,CACA,CAEQ,cAAe,CACnB,GAAI,CAAC,IAAI,CAAC,aAAa,EAAI,CAAE,CAAA,IAAI,CAAC,aAAa,YAAY,iBAAA,EAEvD,MADA,QAAQ,KAAK,CAAC,CAAC,qDAAqD,EAAE,AAAA,EAAA,MAAK,CAAE,eAAe,CAAA,CAAE,EACxF,AAAI,QAGd,GAAI,CAAC,IAAI,CAAC,gBAAgB,EAAI,CAAE,CAAA,IAAI,CAAC,gBAAgB,YAAY,gBAAA,EAE7D,MADA,QAAQ,KAAK,CAAC,CAAC,mDAAmD,EAAE,AAAA,EAAA,MAAK,CAAE,kBAAkB,CAAA,CAAE,EACzF,AAAI,QAGd,GAAI,CAAC,IAAI,CAAC,SAAS,EAAI,CAAE,CAAA,IAAI,CAAC,SAAS,YAAY,WAAA,EAE/C,MADA,QAAQ,KAAK,CAAC,CAAC,uDAAuD,EAAE,AAAA,EAAA,MAAK,CAAE,kBAAkB,CAAA,CAAE,EAC7F,AAAI,OAElB,CACJ,C,G,E,Q,S,C,C,C,E,E,E,O,C,sB,I,GCrHO,IAAW,EAAA,G,CAAA,E,C,G,K,C,Q,E,K,C,QAAA,E,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,G,I,E,E,QCDX,OAAM,E,M,CACe,IAAA,CAAA,YAAA,CAAe,G,C,A,M,CACf,IAAA,CAAA,IAAA,CAAO,AAAU,EAAV,KAAK,EAAE,A,C,AAWtC,aAAqB,CAHrB,IAAA,CACQ,MAAA,CAAuB,IAAI,aAAa,EAE1B,CAEtB,IAAW,MAA+B,CACtC,OAAO,IAAI,CAAC,MAAM,AACtB,CAEO,KAAK,CAAmB,CAAQ,CACnC,IAAI,CAAC,MAAM,CAAG,AAAA,CAAA,EAAA,EAAA,cAAa,AAAb,EAAe,IAAI,CAAC,MAAM,CAAE,AAAc,EAAd,GAE1C,IAAK,IAAI,EAAU,EAAG,EAAU,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,GAAW,EAC3D,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,EAAI,IAAI,CAAC,IAAI,CAAC,EAAU,EAAE,CAClD,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,EAAI,IAAI,CAAC,IAAI,CAAC,EAAU,EAAE,CAClD,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,EAAI,EAAkB,YAAY,AAElE,CAEO,IAAI,CAAC,EAAG,CAAM,CAAE,EAAG,CAAM,CAAa,CAAQ,CACjD,IAAK,IAAI,EAAU,EAAG,EAAU,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,GAAW,EAAG,CAE9D,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,CAAG,EAC3B,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,CAAG,EAC3B,IAAM,EAAY,AAA2B,GAA3B,KAAK,IAAI,CAAC,KAAK,MAAM,IACjC,EAAQ,KAAK,MAAM,GAAK,EAAkB,IAAI,AAEpD,CAAA,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,CAAG,KAAK,GAAG,CAAC,GAAS,EAC7C,IAAI,CAAC,MAAM,CAAC,EAAU,EAAE,CAAG,KAAK,GAAG,CAAC,GAAS,CACjD,CACJ,CACJ,C,G,E,Q,S,C,C,C,E,E,E,O,C,iB,I,GC7CO,IAAM,EAAiB,CAAC,EAA6B,KACxD,IAAM,EAAU,IAAI,aAAa,GAEjC,OADA,EAAQ,GAAG,CAAC,EAAI,QAAQ,CAAC,EAAG,KAAK,GAAG,CAAC,EAAI,MAAM,CAAE,KAC1C,CACX,C,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,C,EGJA,EAAe,6U,I,E,C,ECAf,EAAe,oGFMR,OAAM,EAOT,YAAoC,CAA4B,CAAE,CAA9B,IAAA,CAAA,SAAA,CAAA,EAJ5B,IAAA,CAAA,iBAAA,CAAiD,KACjD,IAAA,CAAA,sBAAA,CAAyB,EACzB,IAAA,CAAA,SAAA,CAAY,EAGhB,IAAM,EAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,SAAU,CAAE,MAAO,CAAA,EAAO,UAAW,CAAA,CAAM,IACrE,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAS,CAAE,MAAO,CAAA,EAAO,UAAW,CAAA,CAAM,GAEhF,GAAI,CAAC,EAED,MADA,QAAQ,KAAK,CAAC,0CAA2C,GACnD,OAGV,CAAA,IAAI,CAAC,OAAO,CAAG,EACf,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,aAAa,GAEzC,IAAI,CAAC,IAAI,EACb,CAEQ,MAAO,CACX,IAAM,EAAK,IAAI,CAAC,OAAO,CAEvB,EAAG,UAAU,CACT,IAAI,CAAC,OAAO,CAAC,YAAY,CACzB,IAAI,CAAC,OAAO,CAAC,YAAY,IAG7B,EAAG,UAAU,CAAC,EAAG,EAAG,EAAG,GAGvB,IAAI,CAAC,uBAAuB,CAAC,EAAA,GAAiB,EAAG,aAAa,EAC9D,IAAI,CAAC,uBAAuB,CAAC,EAAA,GAAiB,EAAG,eAAe,EAEhE,EAAG,WAAW,CAAC,IAAI,CAAC,OAAO,EAC3B,EAAG,UAAU,CAAC,IAAI,CAAC,OAAO,EAE1B,IAAI,CAAC,iBAAiB,CAAG,EAAG,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAE,aAE7D,IAAM,EAAoB,EAAG,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAE,SAC7D,EAAG,uBAAuB,CAAC,GAK3B,EAAG,mBAAmB,CAClB,EACA,EACA,EAAG,KAAK,CACR,CAAA,EACA,GACA,GAIJ,IAAM,EAAQ,IAAI,CAAC,SAAS,CAAC,WAAW,CAClC,EAAS,IAAI,CAAC,SAAS,CAAC,YAAY,CAE1C,EAAG,QAAQ,CAAC,EAAG,EAAG,EAAO,EAC7B,CAEQ,wBAAwB,CAAe,CAAE,CAAY,CAAQ,CACjE,IAAM,EAAK,IAAI,CAAC,OAAO,CAEjB,EAAS,EAAG,YAAY,CAAC,GAE/B,GAAI,CAAC,EAED,MADA,QAAQ,KAAK,CAAC,iCACR,AAAI,QAGd,EAAG,YAAY,CAAC,EAAQ,GACxB,EAAG,aAAa,CAAC,GACjB,QAAQ,GAAG,CAAC,EAAG,gBAAgB,CAAC,IAEhC,EAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAE,EAClC,CAEO,aAAa,CAAiB,CAAQ,CACzC,IAAI,CAAC,SAAS,CAAG,EAEb,IAAI,CAAC,iBAAiB,EACtB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,iBAAiB,CAAE,EAEvD,CAEO,OAAO,CAAkB,CAAE,CAAoB,CAAQ,CAC1D,IAAM,EAAK,IAAI,CAAC,OAAO,CAEjB,EAAoB,EAAG,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAE,SAC7D,QAAQ,GAAG,CAAC,GACZ,EAAG,wBAAwB,CAAC,GAC5B,EAAG,cAAc,CACb,EACA,EAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CACxB,GAAK,IAAI,CAAC,SAAS,CAAC,MAAM,EAG9B,EAAG,UAAU,CACT,EAAG,YAAY,CACf,EAAK,QAAQ,CAAC,EAAG,AAAe,EAAf,GACjB,EAAG,YAAY,EAGnB,EAAG,KAAK,CAAC,EAAG,gBAAgB,EAC5B,EAAG,UAAU,CAAC,EAAG,MAAM,CAAE,EAAG,EAEhC,CACJ,EDvFA,AAtBA,WACI,IAAM,EAAmB,SAAS,cAAc,CAAC,AAAA,EAAA,MAAK,CAAE,kBAAkB,EACpE,EAAY,SAAS,cAAc,CAAC,AAAA,EAAA,MAAK,CAAE,gBAAgB,EAC3D,EAAwB,SAAS,cAAc,CAAC,AAAA,EAAA,MAAK,CAAE,eAAe,EACtE,EAAgB,SAAS,cAAc,CAAC,AAAA,EAAA,MAAK,CAAE,eAAe,EAC9D,EAA0B,GAAI,CAAA,EAAA,EAAA,iBAAgB,AAAhB,EAC9B,EAAsB,IAAI,EAAoB,GAE9C,EAAkB,GAAI,CAAA,EAAA,EAAA,eAAc,AAAd,EACxB,EACA,EACA,AAAA,EAAA,mBAAkB,CAAE,KAAK,CACzB,EACA,EACA,EACA,GAGJ,EAAgB,aAAa,GAC7B,EAAgB,cAAc,EAClC","sources":["<anon>","src/core/config.ts","src/core/points-animation.ts","src/core/types.ts","src/core/pure-javascipt/physics.ts","src/utils.ts","src/run-webgl.ts","src/core/webgl/renderer.ts","src/core/webgl/vert.glsl","src/core/webgl/frag.glsl"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire8661\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire8661\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"4D3px\", function(module, exports) {\n\n$parcel$export(module.exports, \"Config\", () => $ff5f6b9319289f6f$export$29cd7b75162a9425);\nconst $ff5f6b9319289f6f$export$29cd7b75162a9425 = Object.freeze({\n    canvasElementId: 'app-canvas',\n    pointsCountInputId: 'app-points-count-input',\n    fpsOutputBlockId: 'app-fps-output',\n    pointsSizeInput: 'app-point-size-input'\n});\n\n});\n\nparcelRegister(\"fypJ4\", function(module, exports) {\n\n$parcel$export(module.exports, \"PointsAnimation\", () => $1743825ea9f69f1e$export$ff7672a891328c06);\n\nvar $4D3px = parcelRequire(\"4D3px\");\n\nvar $3V8rW = parcelRequire(\"3V8rW\");\nclass $1743825ea9f69f1e$export$ff7672a891328c06 {\n    constructor(physics, renderer, renderingtType, canvasElement, pointsCountInput, fpsOutput, pointsSizeChangeInput){\n        this.physics = physics;\n        this.renderer = renderer;\n        this.renderingtType = renderingtType;\n        this.canvasElement = canvasElement;\n        this.pointsCountInput = pointsCountInput;\n        this.fpsOutput = fpsOutput;\n        this.pointsSizeChangeInput = pointsSizeChangeInput;\n        this.pointsCount = 0;\n        this.canvasSize = {\n            width: 0,\n            height: 0\n        };\n        this.handlePointSizeChange = (event)=>{\n            this.renderer.setPointSize(Number(event.currentTarget.value));\n        };\n        this.handleInput = ()=>{\n            const parsed = Number(this.pointsCountInput.value);\n            if (parsed > 1) this.pointsCount = parsed;\n        };\n        this.handleClick = (event)=>{\n            const clickCoordinate = this.renderingtType === (0, $3V8rW.CanvasRenderingType).Usual ? this.getClickCoordinatesForUsualCanvas(event) : this.getClickCoordinatesForWebGLCanvas(event);\n            this.physics.run(clickCoordinate);\n        };\n        this.validateHTML();\n    }\n    startListening() {\n        let lastTs = 0;\n        let framesDrawn = 0;\n        const frame = (timestamp = 0)=>{\n            window.requestAnimationFrame(frame);\n            this.physics.tick(this.pointsCount);\n            this.renderer.render(this.physics.data, this.pointsCount, this.canvasSize);\n            ++framesDrawn;\n            if (timestamp > lastTs + 2000) {\n                this.fpsOutput.innerText = (1000 * framesDrawn / (timestamp - lastTs)).toFixed(2);\n                lastTs = timestamp;\n                framesDrawn = 0;\n            }\n        };\n        frame();\n    }\n    setupHandlers() {\n        this.canvasElement.width = this.canvasElement.clientWidth;\n        this.canvasElement.height = this.canvasElement.clientHeight;\n        this.canvasSize = {\n            width: this.canvasElement.clientWidth,\n            height: this.canvasElement.clientHeight\n        };\n        this.pointsCountInput.addEventListener('input', this.handleInput);\n        this.handleInput(); // initial assigment\n        this.canvasElement.addEventListener('click', this.handleClick);\n        this.pointsSizeChangeInput.addEventListener('input', this.handlePointSizeChange);\n    }\n    getClickCoordinatesForUsualCanvas(event) {\n        const rect = this.canvasElement.getBoundingClientRect();\n        return {\n            x: event.clientX - rect.left,\n            y: event.clientY - rect.top\n        };\n    }\n    getClickCoordinatesForWebGLCanvas(event) {\n        const rect = this.canvasElement.getBoundingClientRect();\n        // Координаты клика в пикселях относительно canvas\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        // Преобразуем в координаты относительно ЦЕНТРА canvas\n        const centerX = x - this.canvasElement.clientWidth / 2;\n        const centerY = y - this.canvasElement.clientHeight / 2;\n        console.log('Click in pixels from center:', centerX, centerY);\n        return {\n            x: centerX,\n            y: centerY\n        };\n    }\n    validateHTML() {\n        if (!this.canvasElement || !(this.canvasElement instanceof HTMLCanvasElement)) {\n            console.error(`[App]: Canvas element not found. Add <canvas/> with #${(0, $4D3px.Config).canvasElementId}`);\n            throw new Error();\n        }\n        if (!this.pointsCountInput || !(this.pointsCountInput instanceof HTMLInputElement)) {\n            console.error(`[App]: Input element not found. Add <input/> with #${(0, $4D3px.Config).pointsCountInputId}`);\n            throw new Error();\n        }\n        if (!this.fpsOutput || !(this.fpsOutput instanceof HTMLElement)) {\n            console.error(`[App]: FPS output element not found. Add element with #${(0, $4D3px.Config).pointsCountInputId}`);\n            throw new Error();\n        }\n    }\n}\n\n});\nparcelRegister(\"3V8rW\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasRenderingType\", () => $5d5d0272ed9319df$export$2d515545fb3e062b);\nvar $5d5d0272ed9319df$export$2d515545fb3e062b = /*#__PURE__*/ function(CanvasRenderingType) {\n    CanvasRenderingType[\"Usual\"] = \"Usual\";\n    CanvasRenderingType[\"WebGL\"] = \"WebGL\";\n    return CanvasRenderingType;\n}({});\n\n});\n\n\nparcelRegister(\"aP3eO\", function(module, exports) {\n\n$parcel$export(module.exports, \"JavaScriptPhysics\", () => $c64c57661656c421$export$219fb17ee3299b7a);\n\nvar $mDWTX = parcelRequire(\"mDWTX\");\nclass $c64c57661656c421$export$219fb17ee3299b7a {\n    static{\n        this.Acceleration = 0.01;\n    }\n    static{\n        this.PI_2 = Math.PI * 2;\n    }\n    constructor(){\n        /*\r\n    [\r\n        x, y, dx, dy, // For every point: coordinates: x, y; dx, dy -- current speed of changing coord on every tick,\r\n        x, y, dx, dy,\r\n        ...\r\n    ]\r\n    */ this.points = new Float32Array(0);\n    }\n    get data() {\n        return this.points;\n    }\n    tick(pointsCount) {\n        this.points = (0, $mDWTX.resizeF32Array)(this.points, pointsCount * 4); // pointsCount * 4 ==> for every point 4 params\n        for(let pointer = 0; pointer < this.points.length; pointer += 4){\n            this.points[pointer + 0] += this.data[pointer + 2]; // x += dx\n            this.points[pointer + 1] += this.data[pointer + 3]; // y += dy\n            this.points[pointer + 3] += $c64c57661656c421$export$219fb17ee3299b7a.Acceleration; // dy += acceleration (smth like gravity, to make not constant speed, but increasing)\n        }\n    }\n    run({ x: startX, y: startY }) {\n        for(let pointer = 0; pointer < this.points.length; pointer += 4){\n            // Filling all array with points in the click place with same coords, but different direction and start speed\n            this.points[pointer + 0] = startX;\n            this.points[pointer + 1] = startY;\n            const amplitude = Math.sqrt(Math.random()) * 29; // just suitable constant\n            const angle = Math.random() * $c64c57661656c421$export$219fb17ee3299b7a.PI_2;\n            this.points[pointer + 2] = Math.cos(angle) * amplitude;\n            this.points[pointer + 3] = Math.sin(angle) * amplitude;\n        }\n    }\n}\n\n});\nparcelRegister(\"mDWTX\", function(module, exports) {\n\n$parcel$export(module.exports, \"resizeF32Array\", () => $df5bef30413a053b$export$f4d452a2285a5605);\nconst $df5bef30413a053b$export$f4d452a2285a5605 = (old, newLength)=>{\n    const resized = new Float32Array(newLength);\n    resized.set(old.subarray(0, Math.min(old.length, newLength)));\n    return resized;\n};\n\n});\n\n\n\nvar $4D3px = parcelRequire(\"4D3px\");\n\nvar $fypJ4 = parcelRequire(\"fypJ4\");\n\nvar $aP3eO = parcelRequire(\"aP3eO\");\n\nvar $3V8rW = parcelRequire(\"3V8rW\");\nvar $3fb2cfadc40a7592$exports = {};\n$3fb2cfadc40a7592$exports = \"precision lowp float;\\n#define GLSLIFY 1\\n // \\u0442\\u043E\\u0447\\u043D\\u043E\\u0441\\u0442\\u044C\\n\\nattribute vec2 coord;\\nattribute vec2 scale;\\nuniform float pointSize; // for controling point size from JS\\n\\nvoid main() {\\n    gl_Position = vec4(\\n        coord.x * scale.x,\\n        coord.y * scale.y,\\n        0,\\n        1\\n    );\\n\\n    gl_PointSize = pointSize;\\n}\";\n\n\nvar $60fdaeada3b90db6$exports = {};\n$60fdaeada3b90db6$exports = \"precision lowp float;\\n#define GLSLIFY 1\\n\\nvoid main() {\\n    gl_FragColor = vec4(1, 1, 1, 1);\\n}\";\n\n\nclass $6d0b5afe70ebbb35$export$26f22fb1a1824ec1 {\n    constructor(canvasRef){\n        this.canvasRef = canvasRef;\n        this.pointSizeLocation = null;\n        this.firstTimeResizeCounter = 0;\n        this.pointSize = 2.0;\n        const ctx = this.canvasRef.getContext('webgl2', {\n            alpha: false,\n            antialias: false\n        }) || this.canvasRef.getContext('webgl', {\n            alpha: false,\n            antialias: false\n        });\n        if (!ctx) {\n            console.error('[App]: Can not get context from canvas ', canvasRef);\n            throw Error();\n        }\n        this.context = ctx;\n        this.program = this.context.createProgram();\n        this.init();\n    }\n    init() {\n        const gl = this.context;\n        gl.bindBuffer(this.context.ARRAY_BUFFER, this.context.createBuffer());\n        gl.clearColor(0, 0, 0, 1);\n        this.loadCompileAttachShader((0, (/*@__PURE__*/$parcel$interopDefault($3fb2cfadc40a7592$exports))), gl.VERTEX_SHADER);\n        this.loadCompileAttachShader((0, (/*@__PURE__*/$parcel$interopDefault($60fdaeada3b90db6$exports))), gl.FRAGMENT_SHADER);\n        gl.linkProgram(this.program);\n        gl.useProgram(this.program);\n        this.pointSizeLocation = gl.getUniformLocation(this.program, 'pointSize');\n        const attributeLocation = gl.getAttribLocation(this.program, 'coord');\n        gl.enableVertexAttribArray(attributeLocation);\n        // ниже -- описание того, как хранятся данные Float32Array: \n        //  [\n        //      x, y, dx, dy\n        //  ]\n        gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 16, 0 // смещение начала массива\n        );\n        const width = this.canvasRef.clientWidth;\n        const height = this.canvasRef.clientHeight;\n        gl.viewport(0, 0, width, height);\n    }\n    loadCompileAttachShader(content, type) {\n        const gl = this.context;\n        const shader = gl.createShader(type);\n        if (!shader) {\n            console.error('[App]: Can not create shader ');\n            throw new Error();\n        }\n        gl.shaderSource(shader, content);\n        gl.compileShader(shader);\n        console.log(gl.getShaderInfoLog(shader));\n        gl.attachShader(this.program, shader);\n    }\n    setPointSize(pointSize) {\n        this.pointSize = pointSize;\n        if (this.pointSizeLocation) this.context.uniform1f(this.pointSizeLocation, pointSize);\n    }\n    render(data, pointsAmount) {\n        const gl = this.context;\n        const attributeLocation = gl.getAttribLocation(this.program, 'scale');\n        console.log(attributeLocation);\n        gl.disableVertexAttribArray(attributeLocation);\n        gl.vertexAttrib2f(attributeLocation, 2 / this.canvasRef.width, -2 / this.canvasRef.height);\n        gl.bufferData(gl.ARRAY_BUFFER, data.subarray(0, pointsAmount * 4), gl.DYNAMIC_DRAW);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.drawArrays(gl.POINTS, 0, pointsAmount);\n    }\n}\n\n\nfunction $c91ee125d757431e$var$main() {\n    const pointsCountInput = document.getElementById((0, $4D3px.Config).pointsCountInputId);\n    const fpsOutput = document.getElementById((0, $4D3px.Config).fpsOutputBlockId);\n    const pointsSizeChangeInput = document.getElementById((0, $4D3px.Config).pointsSizeInput);\n    const canvasElement = document.getElementById((0, $4D3px.Config).canvasElementId);\n    const physicsJavaScriptEngine = new (0, $aP3eO.JavaScriptPhysics)();\n    const webglCanvasRenderer = new (0, $6d0b5afe70ebbb35$export$26f22fb1a1824ec1)(canvasElement);\n    const pointsAnimation = new (0, $fypJ4.PointsAnimation)(physicsJavaScriptEngine, webglCanvasRenderer, (0, $3V8rW.CanvasRenderingType).WebGL, canvasElement, pointsCountInput, fpsOutput, pointsSizeChangeInput);\n    pointsAnimation.setupHandlers();\n    pointsAnimation.startListening();\n}\n$c91ee125d757431e$var$main();\n\n\n//# sourceMappingURL=webgl.8ded356e.js.map\n","export const Config = Object.freeze({\r\n    canvasElementId: 'app-canvas',\r\n    pointsCountInputId: 'app-points-count-input',\r\n    fpsOutputBlockId: 'app-fps-output',\r\n    pointsSizeInput: 'app-point-size-input'\r\n});","import { Config } from './config';\r\nimport { CanvasRenderingType, Coordinate, Dimension, Renderer, type Physics } from './types';\r\n\r\n\r\nexport class PointsAnimation {\r\n    private pointsCount: number = 0;\r\n    private canvasSize: Dimension = { width: 0, height: 0 };\r\n\r\n    public constructor(\r\n        private readonly physics: Physics,\r\n        private readonly renderer: Renderer,\r\n        private readonly renderingtType: CanvasRenderingType,\r\n        private readonly canvasElement: HTMLCanvasElement,\r\n        private readonly pointsCountInput: HTMLInputElement,\r\n        private readonly fpsOutput: HTMLElement,\r\n        private readonly pointsSizeChangeInput: HTMLInputElement\r\n    ) {\r\n        this.validateHTML();\r\n    }\r\n\r\n    public startListening(): void {\r\n        let lastTs = 0;\r\n        let framesDrawn = 0;\r\n\r\n        const frame = (timestamp: number = 0) => {\r\n            window.requestAnimationFrame(frame);\r\n\r\n            this.physics.tick(this.pointsCount);\r\n            this.renderer.render(this.physics.data, this.pointsCount, this.canvasSize);\r\n\r\n            ++framesDrawn;\r\n\r\n            if (timestamp > lastTs + 2000) {\r\n                this.fpsOutput.innerText = (1000 * framesDrawn / (timestamp - lastTs)).toFixed(2);\r\n                lastTs = timestamp;\r\n                framesDrawn = 0;\r\n            }\r\n        }\r\n\r\n        frame();\r\n    }\r\n\r\n    public setupHandlers(): void {\r\n        this.canvasElement.width = this.canvasElement.clientWidth;\r\n        this.canvasElement.height = this.canvasElement.clientHeight;\r\n         this.canvasSize = {\r\n            width: this.canvasElement.clientWidth,\r\n            height: this.canvasElement.clientHeight\r\n        };\r\n\r\n        this.pointsCountInput.addEventListener('input', this.handleInput);\r\n        this.handleInput(); // initial assigment\r\n\r\n        this.canvasElement.addEventListener('click', this.handleClick);\r\n\r\n        this.pointsSizeChangeInput.addEventListener('input', this.handlePointSizeChange)\r\n    }\r\n\r\n    private readonly handlePointSizeChange = (event: Event): void => {\r\n        this.renderer.setPointSize(Number((event.currentTarget as HTMLInputElement).value))\r\n    }\r\n\r\n    private readonly handleInput = () => {\r\n        const parsed = Number(this.pointsCountInput.value);\r\n\r\n        if (parsed > 1) {\r\n            this.pointsCount = parsed;\r\n        }\r\n    }\r\n\r\n    private readonly handleClick = (event: MouseEvent) => {\r\n        const clickCoordinate: Coordinate = this.renderingtType === CanvasRenderingType.Usual\r\n            ? this.getClickCoordinatesForUsualCanvas(event)\r\n            : this.getClickCoordinatesForWebGLCanvas(event);\r\n\r\n        this.physics.run(clickCoordinate);\r\n    };\r\n\r\n    private getClickCoordinatesForUsualCanvas(event: MouseEvent): Coordinate {\r\n        const rect = this.canvasElement.getBoundingClientRect();\r\n\r\n        return {\r\n            x: event.clientX - rect.left,\r\n            y: event.clientY - rect.top\r\n        };\r\n    }\r\n\r\n    private getClickCoordinatesForWebGLCanvas(event: MouseEvent): Coordinate {\r\n         const rect = this.canvasElement.getBoundingClientRect();\r\n\r\n    // Координаты клика в пикселях относительно canvas\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n\r\n    // Преобразуем в координаты относительно ЦЕНТРА canvas\r\n    const centerX = x - this.canvasElement.clientWidth / 2;\r\n    const centerY = y - this.canvasElement.clientHeight / 2;\r\n\r\n    console.log('Click in pixels from center:', centerX, centerY);\r\n    \r\n    return { \r\n        x: centerX, \r\n        y: centerY \r\n    };\r\n    }\r\n\r\n    private validateHTML() {\r\n        if (!this.canvasElement || !(this.canvasElement instanceof HTMLCanvasElement)) {\r\n            console.error(`[App]: Canvas element not found. Add <canvas/> with #${Config.canvasElementId}`);\r\n            throw new Error();\r\n        }\r\n\r\n        if (!this.pointsCountInput || !(this.pointsCountInput instanceof HTMLInputElement)) {\r\n            console.error(`[App]: Input element not found. Add <input/> with #${Config.pointsCountInputId}`);\r\n            throw new Error();\r\n        }\r\n\r\n        if (!this.fpsOutput || !(this.fpsOutput instanceof HTMLElement)) {\r\n            console.error(`[App]: FPS output element not found. Add element with #${Config.pointsCountInputId}`);\r\n            throw new Error();\r\n        }\r\n    }\r\n}","export interface Dimension {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport const enum CanvasRenderingType {\r\n    Usual = 'Usual',\r\n    WebGL = 'WebGL'\r\n};\r\n\r\nexport interface Coordinate {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface Physics {\r\n    run: (coordinate: Coordinate) => void;\r\n    tick: (pointsCount: number) => void;\r\n    data: Readonly<Float32Array>;\r\n}\r\n\r\nexport interface Renderer {\r\n    setPointSize: (pointSize: number) => void;\r\n    render: (data: Float32Array, pointsAmount: number, {width, height}: Dimension) => void;\r\n}","import { resizeF32Array } from '../../utils';\r\nimport { Coordinate, Physics } from '../types';\r\n\r\n\r\nexport class JavaScriptPhysics implements Physics {\r\n    private static readonly Acceleration = 0.01;\r\n    private static readonly PI_2 = Math.PI * 2;\r\n     \r\n    /*\r\n    [\r\n        x, y, dx, dy, // For every point: coordinates: x, y; dx, dy -- current speed of changing coord on every tick,\r\n        x, y, dx, dy,\r\n        ...\r\n    ]\r\n    */\r\n    private points: Float32Array = new Float32Array(0);\r\n\r\n    public constructor() {}\r\n\r\n    public get data(): Readonly<Float32Array> {\r\n        return this.points;\r\n    }\r\n\r\n    public tick(pointsCount: number): void {\r\n        this.points = resizeF32Array(this.points, pointsCount * 4); // pointsCount * 4 ==> for every point 4 params\r\n\r\n        for (let pointer = 0; pointer < this.points.length; pointer += 4) {\r\n            this.points[pointer + 0] += this.data[pointer + 2]; // x += dx\r\n            this.points[pointer + 1] += this.data[pointer + 3]; // y += dy\r\n            this.points[pointer + 3] += JavaScriptPhysics.Acceleration; // dy += acceleration (smth like gravity, to make not constant speed, but increasing)\r\n        }\r\n    }\r\n\r\n    public run({x: startX, y: startY}: Coordinate): void {\r\n        for (let pointer = 0; pointer < this.points.length; pointer += 4) {\r\n            // Filling all array with points in the click place with same coords, but different direction and start speed\r\n            this.points[pointer + 0] = startX; \r\n            this.points[pointer + 1] = startY;\r\n            const amplitude = Math.sqrt(Math.random()) * 29; // just suitable constant\r\n            const angle = Math.random() * JavaScriptPhysics.PI_2;\r\n\r\n            this.points[pointer + 2] = Math.cos(angle) * amplitude; \r\n            this.points[pointer + 3] = Math.sin(angle) * amplitude;\r\n        }\r\n    }\r\n}","export const resizeF32Array = (old: Readonly<Float32Array>, newLength: number): Float32Array => {\r\n    const resized = new Float32Array(newLength);\r\n    resized.set(old.subarray(0, Math.min(old.length, newLength)));\r\n    return resized;\r\n};","import { Config } from './core/config';\r\nimport { PointsAnimation } from './core/points-animation';\r\nimport { JavaScriptPhysics } from './core/pure-javascipt/physics';\r\nimport { CanvasRenderingType } from './core/types';\r\nimport { WebGLCanvasRenderer } from './core/webgl/renderer';\r\n\r\n\r\nfunction main() {\r\n    const pointsCountInput = document.getElementById(Config.pointsCountInputId) as HTMLInputElement;\r\n    const fpsOutput = document.getElementById(Config.fpsOutputBlockId) as HTMLElement;\r\n    const pointsSizeChangeInput = document.getElementById(Config.pointsSizeInput) as HTMLInputElement;\r\n    const canvasElement = document.getElementById(Config.canvasElementId) as HTMLCanvasElement\r\n    const physicsJavaScriptEngine = new JavaScriptPhysics();\r\n    const webglCanvasRenderer = new WebGLCanvasRenderer(canvasElement);\r\n\r\n    const pointsAnimation = new PointsAnimation(\r\n        physicsJavaScriptEngine,\r\n        webglCanvasRenderer, \r\n        CanvasRenderingType.WebGL,\r\n        canvasElement, \r\n        pointsCountInput,\r\n        fpsOutput,\r\n        pointsSizeChangeInput\r\n    );\r\n\r\n    pointsAnimation.setupHandlers();\r\n    pointsAnimation.startListening();\r\n}\r\n\r\nmain();","import { Dimension, Renderer } from '../types';\r\nimport { Config } from '../config';\r\nimport VertGlslContent from './vert.glsl';\r\nimport FragGlslContent from './frag.glsl';\r\n\r\n\r\nexport class WebGLCanvasRenderer implements Renderer {\r\n    private readonly context: WebGLRenderingContext;\r\n    private readonly program: WebGLProgram;\r\n    private pointSizeLocation: WebGLUniformLocation | null = null;\r\n    private firstTimeResizeCounter = 0;\r\n    private pointSize = 2.0;\r\n\r\n    public constructor(private readonly canvasRef: HTMLCanvasElement) {\r\n        const ctx = this.canvasRef.getContext('webgl2', { alpha: false, antialias: false }) ||\r\n                    this.canvasRef.getContext('webgl', { alpha: false, antialias: false });\r\n\r\n        if (!ctx) {\r\n            console.error('[App]: Can not get context from canvas ', canvasRef);\r\n            throw Error();\r\n        }\r\n\r\n        this.context = ctx;\r\n        this.program = this.context.createProgram();\r\n\r\n        this.init();\r\n    }\r\n\r\n    private init() {\r\n        const gl = this.context;\r\n\r\n        gl.bindBuffer(\r\n            this.context.ARRAY_BUFFER,\r\n            this.context.createBuffer()\r\n        );\r\n\r\n        gl.clearColor(0, 0, 0, 1);\r\n\r\n\r\n        this.loadCompileAttachShader(VertGlslContent, gl.VERTEX_SHADER);\r\n        this.loadCompileAttachShader(FragGlslContent, gl.FRAGMENT_SHADER);\r\n\r\n        gl.linkProgram(this.program);\r\n        gl.useProgram(this.program);\r\n\r\n        this.pointSizeLocation = gl.getUniformLocation(this.program, 'pointSize');\r\n\r\n        const attributeLocation = gl.getAttribLocation(this.program, 'coord');\r\n        gl.enableVertexAttribArray(attributeLocation);\r\n        // ниже -- описание того, как хранятся данные Float32Array: \r\n        //  [\r\n        //      x, y, dx, dy\r\n        //  ]\r\n        gl.vertexAttribPointer(\r\n            attributeLocation, // индекс атрибута\r\n            2, // число компонент вектора - 2 - x, y\r\n            gl.FLOAT, // тип данных float32\r\n            false, // нормализация\r\n            16, // расстояние в байтах между атрибутами\r\n            0 // смещение начала массива\r\n        );\r\n\r\n        \r\n        const width = this.canvasRef.clientWidth;\r\n        const height = this.canvasRef.clientHeight\r\n        \r\n        gl.viewport(0, 0, width, height);\r\n    }\r\n\r\n    private loadCompileAttachShader(content: string, type: number): void {\r\n        const gl = this.context;\r\n\r\n        const shader = gl.createShader(type);\r\n\r\n        if (!shader) {\r\n            console.error('[App]: Can not create shader ');\r\n            throw new Error();\r\n        }\r\n\r\n        gl.shaderSource(shader, content);\r\n        gl.compileShader(shader);\r\n        console.log(gl.getShaderInfoLog(shader));\r\n\r\n        gl.attachShader(this.program, shader);\r\n    }\r\n\r\n    public setPointSize(pointSize: number): void {\r\n        this.pointSize = pointSize;\r\n        \r\n        if (this.pointSizeLocation) {\r\n            this.context.uniform1f(this.pointSizeLocation, pointSize);\r\n        }\r\n    };\r\n\r\n    public render(data: Float32Array, pointsAmount: number): void {\r\n        const gl = this.context;\r\n\r\n        const attributeLocation = gl.getAttribLocation(this.program, 'scale');\r\n        console.log(attributeLocation)\r\n        gl.disableVertexAttribArray(attributeLocation);\r\n        gl.vertexAttrib2f(\r\n            attributeLocation,\r\n            2 / this.canvasRef.width,\r\n            -2 / this.canvasRef.height\r\n        );\r\n\r\n        gl.bufferData(\r\n            gl.ARRAY_BUFFER,\r\n            data.subarray(0, pointsAmount * 4),\r\n            gl.DYNAMIC_DRAW\r\n        );\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        gl.drawArrays(gl.POINTS, 0, pointsAmount);\r\n\r\n    };\r\n}","precision lowp float; // точность\r\n\r\nattribute vec2 coord;\r\nattribute vec2 scale;\r\nuniform float pointSize; // for controling point size from JS\r\n\r\nvoid main() {\r\n    gl_Position = vec4(\r\n        coord.x * scale.x,\r\n        coord.y * scale.y,\r\n        0,\r\n        1\r\n    );\r\n\r\n    gl_PointSize = pointSize;\r\n}","precision lowp float;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(1, 1, 1, 1);\r\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$ff5f6b9319289f6f$export$29cd7b75162a9425","freeze","canvasElementId","pointsCountInputId","fpsOutputBlockId","pointsSizeInput","$1743825ea9f69f1e$export$ff7672a891328c06","$4D3px","$3V8rW","physics","renderer","renderingtType","canvasElement","pointsCountInput","fpsOutput","pointsSizeChangeInput","pointsCount","canvasSize","width","height","handlePointSizeChange","event","setPointSize","Number","currentTarget","value","handleInput","parsed","handleClick","clickCoordinate","CanvasRenderingType","Usual","getClickCoordinatesForUsualCanvas","getClickCoordinatesForWebGLCanvas","run","validateHTML","startListening","lastTs","framesDrawn","frame","timestamp","window","requestAnimationFrame","tick","render","data","innerText","toFixed","setupHandlers","clientWidth","clientHeight","addEventListener","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","centerX","centerY","console","log","HTMLCanvasElement","error","Config","HTMLInputElement","HTMLElement","$5d5d0272ed9319df$export$2d515545fb3e062b","$c64c57661656c421$export$219fb17ee3299b7a","$mDWTX","Acceleration","PI_2","Math","PI","points","Float32Array","resizeF32Array","pointer","length","startX","startY","amplitude","sqrt","random","angle","cos","sin","$df5bef30413a053b$export$f4d452a2285a5605","old","newLength","resized","subarray","min","$fypJ4","$aP3eO","$3fb2cfadc40a7592$exports","$60fdaeada3b90db6$exports","$6d0b5afe70ebbb35$export$26f22fb1a1824ec1","canvasRef","pointSizeLocation","firstTimeResizeCounter","pointSize","ctx","getContext","alpha","antialias","context","program","createProgram","gl","bindBuffer","ARRAY_BUFFER","createBuffer","clearColor","loadCompileAttachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","useProgram","getUniformLocation","attributeLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","viewport","content","type","shader","createShader","shaderSource","compileShader","getShaderInfoLog","attachShader","uniform1f","pointsAmount","disableVertexAttribArray","vertexAttrib2f","bufferData","DYNAMIC_DRAW","clear","COLOR_BUFFER_BIT","drawArrays","POINTS","$c91ee125d757431e$var$main","document","getElementById","physicsJavaScriptEngine","JavaScriptPhysics","webglCanvasRenderer","pointsAnimation","PointsAnimation","WebGL"],"version":3,"file":"webgl.8ded356e.js.map"}