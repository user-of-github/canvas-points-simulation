{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,S,I,GCAO,IAAM,EAAS,OAAO,MAAM,CAAC,CAChC,gBAAiB,aACjB,mBAAoB,yBACpB,iBAAkB,iBAClB,gBAAiB,sBACrB,E,G,E,Q,S,C,C,C,E,E,E,O,C,kB,I,G,I,E,E,S,E,E,QCDO,OAAM,EAIT,YACqB,CAAgB,CAChB,CAAkB,CAClB,CAAmC,CACnC,CAAgC,CAChC,CAAkC,CAClC,CAAsB,CACtB,CAAuC,CAC1D,CAPmB,IAAA,CAAA,OAAA,CAAA,EACA,IAAA,CAAA,QAAA,CAAA,EACA,IAAA,CAAA,cAAA,CAAA,EACA,IAAA,CAAA,aAAA,CAAA,EACA,IAAA,CAAA,gBAAA,CAAA,EACA,IAAA,CAAA,SAAA,CAAA,EACA,IAAA,CAAA,qBAAA,CAAA,EAVb,IAAA,CAAA,WAAA,CAAsB,EACtB,IAAA,CAAA,UAAA,CAAwB,CAAE,MAAO,EAAG,OAAQ,CAAE,EAoDrC,IAAA,CAAA,qBAAA,CAAwB,AAAC,IACtC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,OAAQ,EAAM,aAAa,CAAsB,KAAK,EACrF,EAEiB,IAAA,CAAA,WAAA,CAAc,KAC3B,IAAM,EAAS,OAAO,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAE7C,CAAA,EAAS,GACT,CAAA,IAAI,CAAC,WAAW,CAAG,CADvB,CAGJ,EAEiB,IAAA,CAAA,WAAA,CAAc,AAAC,IAC5B,IAAM,EAA8B,IAAI,CAAC,cAAc,GAAK,AAAA,EAAA,mBAAkB,CAAE,KAAK,CAC/E,IAAI,CAAC,iCAAiC,CAAC,GACvC,IAAI,CAAC,iCAAiC,CAAC,GAE7C,I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","sources":["<anon>","src/core/config.ts","src/core/points-animation.ts","src/core/types.ts","src/core/pure-javascipt/physics.ts","src/utils.ts","src/run-js.ts","src/core/pure-javascipt/renderer.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire8661\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire8661\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"4D3px\", function(module, exports) {\n\n$parcel$export(module.exports, \"Config\", () => $ff5f6b9319289f6f$export$29cd7b75162a9425);\nconst $ff5f6b9319289f6f$export$29cd7b75162a9425 = Object.freeze({\n    canvasElementId: 'app-canvas',\n    pointsCountInputId: 'app-points-count-input',\n    fpsOutputBlockId: 'app-fps-output',\n    pointsSizeInput: 'app-point-size-input'\n});\n\n});\n\nparcelRegister(\"fypJ4\", function(module, exports) {\n\n$parcel$export(module.exports, \"PointsAnimation\", () => $1743825ea9f69f1e$export$ff7672a891328c06);\n\nvar $4D3px = parcelRequire(\"4D3px\");\n\nvar $3V8rW = parcelRequire(\"3V8rW\");\nclass $1743825ea9f69f1e$export$ff7672a891328c06 {\n    constructor(physics, renderer, renderingtType, canvasElement, pointsCountInput, fpsOutput, pointsSizeChangeInput){\n        this.physics = physics;\n        this.renderer = renderer;\n        this.renderingtType = renderingtType;\n        this.canvasElement = canvasElement;\n        this.pointsCountInput = pointsCountInput;\n        this.fpsOutput = fpsOutput;\n        this.pointsSizeChangeInput = pointsSizeChangeInput;\n        this.pointsCount = 0;\n        this.canvasSize = {\n            width: 0,\n            height: 0\n        };\n        this.handlePointSizeChange = (event)=>{\n            this.renderer.setPointSize(Number(event.currentTarget.value));\n        };\n        this.handleInput = ()=>{\n            const parsed = Number(this.pointsCountInput.value);\n            if (parsed > 1) this.pointsCount = parsed;\n        };\n        this.handleClick = (event)=>{\n            const clickCoordinate = this.renderingtType === (0, $3V8rW.CanvasRenderingType).Usual ? this.getClickCoordinatesForUsualCanvas(event) : this.getClickCoordinatesForWebGLCanvas(event);\n            this.physics.run(clickCoordinate);\n        };\n        this.validateHTML();\n    }\n    startListening() {\n        let lastTs = 0;\n        let framesDrawn = 0;\n        const frame = (timestamp = 0)=>{\n            window.requestAnimationFrame(frame);\n            this.physics.tick(this.pointsCount);\n            this.renderer.render(this.physics.data, this.pointsCount, this.canvasSize);\n            ++framesDrawn;\n            if (timestamp > lastTs + 2000) {\n                this.fpsOutput.innerText = (1000 * framesDrawn / (timestamp - lastTs)).toFixed(2);\n                lastTs = timestamp;\n                framesDrawn = 0;\n            }\n        };\n        frame();\n    }\n    setupHandlers() {\n        this.canvasElement.width = this.canvasElement.clientWidth;\n        this.canvasElement.height = this.canvasElement.clientHeight;\n        this.canvasSize = {\n            width: this.canvasElement.clientWidth,\n            height: this.canvasElement.clientHeight\n        };\n        this.pointsCountInput.addEventListener('input', this.handleInput);\n        this.handleInput(); // initial assigment\n        this.canvasElement.addEventListener('click', this.handleClick);\n        this.pointsSizeChangeInput.addEventListener('input', this.handlePointSizeChange);\n    }\n    getClickCoordinatesForUsualCanvas(event) {\n        const rect = this.canvasElement.getBoundingClientRect();\n        return {\n            x: event.clientX - rect.left,\n            y: event.clientY - rect.top\n        };\n    }\n    getClickCoordinatesForWebGLCanvas(event) {\n        const rect = this.canvasElement.getBoundingClientRect();\n        // Координаты клика в пикселях относительно canvas\n        const x = event.clientX - rect.left;\n        const y = event.clientY - rect.top;\n        // Преобразуем в координаты относительно ЦЕНТРА canvas\n        const centerX = x - this.canvasElement.clientWidth / 2;\n        const centerY = y - this.canvasElement.clientHeight / 2;\n        console.log('Click in pixels from center:', centerX, centerY);\n        return {\n            x: centerX,\n            y: centerY\n        };\n    }\n    validateHTML() {\n        if (!this.canvasElement || !(this.canvasElement instanceof HTMLCanvasElement)) {\n            console.error(`[App]: Canvas element not found. Add <canvas/> with #${(0, $4D3px.Config).canvasElementId}`);\n            throw new Error();\n        }\n        if (!this.pointsCountInput || !(this.pointsCountInput instanceof HTMLInputElement)) {\n            console.error(`[App]: Input element not found. Add <input/> with #${(0, $4D3px.Config).pointsCountInputId}`);\n            throw new Error();\n        }\n        if (!this.fpsOutput || !(this.fpsOutput instanceof HTMLElement)) {\n            console.error(`[App]: FPS output element not found. Add element with #${(0, $4D3px.Config).pointsCountInputId}`);\n            throw new Error();\n        }\n    }\n}\n\n});\nparcelRegister(\"3V8rW\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasRenderingType\", () => $5d5d0272ed9319df$export$2d515545fb3e062b);\nvar $5d5d0272ed9319df$export$2d515545fb3e062b = /*#__PURE__*/ function(CanvasRenderingType) {\n    CanvasRenderingType[\"Usual\"] = \"Usual\";\n    CanvasRenderingType[\"WebGL\"] = \"WebGL\";\n    return CanvasRenderingType;\n}({});\n\n});\n\n\nparcelRegister(\"aP3eO\", function(module, exports) {\n\n$parcel$export(module.exports, \"JavaScriptPhysics\", () => $c64c57661656c421$export$219fb17ee3299b7a);\n\nvar $mDWTX = parcelRequire(\"mDWTX\");\nclass $c64c57661656c421$export$219fb17ee3299b7a {\n    static{\n        this.Acceleration = 0.01;\n    }\n    static{\n        this.PI_2 = Math.PI * 2;\n    }\n    constructor(){\n        /*\r\n    [\r\n        x, y, dx, dy, // For every point: coordinates: x, y; dx, dy -- current speed of changing coord on every tick,\r\n        x, y, dx, dy,\r\n        ...\r\n    ]\r\n    */ this.points = new Float32Array(0);\n    }\n    get data() {\n        return this.points;\n    }\n    tick(pointsCount) {\n        this.points = (0, $mDWTX.resizeF32Array)(this.points, pointsCount * 4); // pointsCount * 4 ==> for every point 4 params\n        for(let pointer = 0; pointer < this.points.length; pointer += 4){\n            this.points[pointer + 0] += this.data[pointer + 2]; // x += dx\n            this.points[pointer + 1] += this.data[pointer + 3]; // y += dy\n            this.points[pointer + 3] += $c64c57661656c421$export$219fb17ee3299b7a.Acceleration; // dy += acceleration (smth like gravity, to make not constant speed, but increasing)\n        }\n    }\n    run({ x: startX, y: startY }) {\n        for(let pointer = 0; pointer < this.points.length; pointer += 4){\n            // Filling all array with points in the click place with same coords, but different direction and start speed\n            this.points[pointer + 0] = startX;\n            this.points[pointer + 1] = startY;\n            const amplitude = Math.sqrt(Math.random()) * 29; // just suitable constant\n            const angle = Math.random() * $c64c57661656c421$export$219fb17ee3299b7a.PI_2;\n            this.points[pointer + 2] = Math.cos(angle) * amplitude;\n            this.points[pointer + 3] = Math.sin(angle) * amplitude;\n        }\n    }\n}\n\n});\nparcelRegister(\"mDWTX\", function(module, exports) {\n\n$parcel$export(module.exports, \"resizeF32Array\", () => $df5bef30413a053b$export$f4d452a2285a5605);\nconst $df5bef30413a053b$export$f4d452a2285a5605 = (old, newLength)=>{\n    const resized = new Float32Array(newLength);\n    resized.set(old.subarray(0, Math.min(old.length, newLength)));\n    return resized;\n};\n\n});\n\n\n\nvar $4D3px = parcelRequire(\"4D3px\");\n\nvar $fypJ4 = parcelRequire(\"fypJ4\");\n\nvar $aP3eO = parcelRequire(\"aP3eO\");\nclass $5deae40f139f9cfd$export$f4a15f06a29916b5 {\n    constructor(canvasRef){\n        this.canvasRef = canvasRef;\n        this.pointSize = 3;\n        const ctx = canvasRef.getContext('2d');\n        if (!ctx) {\n            console.error('[App]: Can not get context from canvas ', canvasRef);\n            throw Error();\n        }\n        this.context = ctx;\n    }\n    render(data, pointsAmount, size) {\n        this.context.fillStyle = 'white';\n        this.context.strokeStyle = 'white';\n        this.context.clearRect(0, 0, size.width, size.height);\n        this.context.beginPath();\n        for(let pointer = 0; pointer < pointsAmount * 4; pointer += 4)this.context.rect(data[pointer + 0] - 1, data[pointer + 1] - 1, this.pointSize, this.pointSize);\n        this.context.fill();\n        this.context.stroke();\n    //this.context.closePath();\n    }\n    setPointSize(size) {\n        this.pointSize = size;\n    }\n}\n\n\n\nvar $3V8rW = parcelRequire(\"3V8rW\");\nfunction $91f00a93702e8c6b$var$main() {\n    const pointsCountInput = document.getElementById((0, $4D3px.Config).pointsCountInputId);\n    const fpsOutput = document.getElementById((0, $4D3px.Config).fpsOutputBlockId);\n    const pointsSizeChangeInput = document.getElementById((0, $4D3px.Config).pointsSizeInput);\n    const canvasElement = document.getElementById((0, $4D3px.Config).canvasElementId);\n    const physicsJavaScriptEngine = new (0, $aP3eO.JavaScriptPhysics)();\n    const javascriptCanvasRenderer = new (0, $5deae40f139f9cfd$export$f4a15f06a29916b5)(canvasElement);\n    const pointsAnimation = new (0, $fypJ4.PointsAnimation)(physicsJavaScriptEngine, javascriptCanvasRenderer, (0, $3V8rW.CanvasRenderingType).Usual, canvasElement, pointsCountInput, fpsOutput, pointsSizeChangeInput);\n    pointsAnimation.setupHandlers();\n    pointsAnimation.startListening();\n}\n$91f00a93702e8c6b$var$main();\n\n\n//# sourceMappingURL=javascript.834ca6e7.js.map\n","export const Config = Object.freeze({\r\n    canvasElementId: 'app-canvas',\r\n    pointsCountInputId: 'app-points-count-input',\r\n    fpsOutputBlockId: 'app-fps-output',\r\n    pointsSizeInput: 'app-point-size-input'\r\n});","import { Config } from './config';\r\nimport { CanvasRenderingType, Coordinate, Dimension, Renderer, type Physics } from './types';\r\n\r\n\r\nexport class PointsAnimation {\r\n    private pointsCount: number = 0;\r\n    private canvasSize: Dimension = { width: 0, height: 0 };\r\n\r\n    public constructor(\r\n        private readonly physics: Physics,\r\n        private readonly renderer: Renderer,\r\n        private readonly renderingtType: CanvasRenderingType,\r\n        private readonly canvasElement: HTMLCanvasElement,\r\n        private readonly pointsCountInput: HTMLInputElement,\r\n        private readonly fpsOutput: HTMLElement,\r\n        private readonly pointsSizeChangeInput: HTMLInputElement\r\n    ) {\r\n        this.validateHTML();\r\n    }\r\n\r\n    public startListening(): void {\r\n        let lastTs = 0;\r\n        let framesDrawn = 0;\r\n\r\n        const frame = (timestamp: number = 0) => {\r\n            window.requestAnimationFrame(frame);\r\n\r\n            this.physics.tick(this.pointsCount);\r\n            this.renderer.render(this.physics.data, this.pointsCount, this.canvasSize);\r\n\r\n            ++framesDrawn;\r\n\r\n            if (timestamp > lastTs + 2000) {\r\n                this.fpsOutput.innerText = (1000 * framesDrawn / (timestamp - lastTs)).toFixed(2);\r\n                lastTs = timestamp;\r\n                framesDrawn = 0;\r\n            }\r\n        }\r\n\r\n        frame();\r\n    }\r\n\r\n    public setupHandlers(): void {\r\n        this.canvasElement.width = this.canvasElement.clientWidth;\r\n        this.canvasElement.height = this.canvasElement.clientHeight;\r\n         this.canvasSize = {\r\n            width: this.canvasElement.clientWidth,\r\n            height: this.canvasElement.clientHeight\r\n        };\r\n\r\n        this.pointsCountInput.addEventListener('input', this.handleInput);\r\n        this.handleInput(); // initial assigment\r\n\r\n        this.canvasElement.addEventListener('click', this.handleClick);\r\n\r\n        this.pointsSizeChangeInput.addEventListener('input', this.handlePointSizeChange)\r\n    }\r\n\r\n    private readonly handlePointSizeChange = (event: Event): void => {\r\n        this.renderer.setPointSize(Number((event.currentTarget as HTMLInputElement).value))\r\n    }\r\n\r\n    private readonly handleInput = () => {\r\n        const parsed = Number(this.pointsCountInput.value);\r\n\r\n        if (parsed > 1) {\r\n            this.pointsCount = parsed;\r\n        }\r\n    }\r\n\r\n    private readonly handleClick = (event: MouseEvent) => {\r\n        const clickCoordinate: Coordinate = this.renderingtType === CanvasRenderingType.Usual\r\n            ? this.getClickCoordinatesForUsualCanvas(event)\r\n            : this.getClickCoordinatesForWebGLCanvas(event);\r\n\r\n        this.physics.run(clickCoordinate);\r\n    };\r\n\r\n    private getClickCoordinatesForUsualCanvas(event: MouseEvent): Coordinate {\r\n        const rect = this.canvasElement.getBoundingClientRect();\r\n\r\n        return {\r\n            x: event.clientX - rect.left,\r\n            y: event.clientY - rect.top\r\n        };\r\n    }\r\n\r\n    private getClickCoordinatesForWebGLCanvas(event: MouseEvent): Coordinate {\r\n         const rect = this.canvasElement.getBoundingClientRect();\r\n\r\n    // Координаты клика в пикселях относительно canvas\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n\r\n    // Преобразуем в координаты относительно ЦЕНТРА canvas\r\n    const centerX = x - this.canvasElement.clientWidth / 2;\r\n    const centerY = y - this.canvasElement.clientHeight / 2;\r\n\r\n    console.log('Click in pixels from center:', centerX, centerY);\r\n    \r\n    return { \r\n        x: centerX, \r\n        y: centerY \r\n    };\r\n    }\r\n\r\n    private validateHTML() {\r\n        if (!this.canvasElement || !(this.canvasElement instanceof HTMLCanvasElement)) {\r\n            console.error(`[App]: Canvas element not found. Add <canvas/> with #${Config.canvasElementId}`);\r\n            throw new Error();\r\n        }\r\n\r\n        if (!this.pointsCountInput || !(this.pointsCountInput instanceof HTMLInputElement)) {\r\n            console.error(`[App]: Input element not found. Add <input/> with #${Config.pointsCountInputId}`);\r\n            throw new Error();\r\n        }\r\n\r\n        if (!this.fpsOutput || !(this.fpsOutput instanceof HTMLElement)) {\r\n            console.error(`[App]: FPS output element not found. Add element with #${Config.pointsCountInputId}`);\r\n            throw new Error();\r\n        }\r\n    }\r\n}","export interface Dimension {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport const enum CanvasRenderingType {\r\n    Usual = 'Usual',\r\n    WebGL = 'WebGL'\r\n};\r\n\r\nexport interface Coordinate {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface Physics {\r\n    run: (coordinate: Coordinate) => void;\r\n    tick: (pointsCount: number) => void;\r\n    data: Readonly<Float32Array>;\r\n}\r\n\r\nexport interface Renderer {\r\n    setPointSize: (pointSize: number) => void;\r\n    render: (data: Float32Array, pointsAmount: number, {width, height}: Dimension) => void;\r\n}","import { resizeF32Array } from '../../utils';\r\nimport { Coordinate, Physics } from '../types';\r\n\r\n\r\nexport class JavaScriptPhysics implements Physics {\r\n    private static readonly Acceleration = 0.01;\r\n    private static readonly PI_2 = Math.PI * 2;\r\n     \r\n    /*\r\n    [\r\n        x, y, dx, dy, // For every point: coordinates: x, y; dx, dy -- current speed of changing coord on every tick,\r\n        x, y, dx, dy,\r\n        ...\r\n    ]\r\n    */\r\n    private points: Float32Array = new Float32Array(0);\r\n\r\n    public constructor() {}\r\n\r\n    public get data(): Readonly<Float32Array> {\r\n        return this.points;\r\n    }\r\n\r\n    public tick(pointsCount: number): void {\r\n        this.points = resizeF32Array(this.points, pointsCount * 4); // pointsCount * 4 ==> for every point 4 params\r\n\r\n        for (let pointer = 0; pointer < this.points.length; pointer += 4) {\r\n            this.points[pointer + 0] += this.data[pointer + 2]; // x += dx\r\n            this.points[pointer + 1] += this.data[pointer + 3]; // y += dy\r\n            this.points[pointer + 3] += JavaScriptPhysics.Acceleration; // dy += acceleration (smth like gravity, to make not constant speed, but increasing)\r\n        }\r\n    }\r\n\r\n    public run({x: startX, y: startY}: Coordinate): void {\r\n        for (let pointer = 0; pointer < this.points.length; pointer += 4) {\r\n            // Filling all array with points in the click place with same coords, but different direction and start speed\r\n            this.points[pointer + 0] = startX; \r\n            this.points[pointer + 1] = startY;\r\n            const amplitude = Math.sqrt(Math.random()) * 29; // just suitable constant\r\n            const angle = Math.random() * JavaScriptPhysics.PI_2;\r\n\r\n            this.points[pointer + 2] = Math.cos(angle) * amplitude; \r\n            this.points[pointer + 3] = Math.sin(angle) * amplitude;\r\n        }\r\n    }\r\n}","export const resizeF32Array = (old: Readonly<Float32Array>, newLength: number): Float32Array => {\r\n    const resized = new Float32Array(newLength);\r\n    resized.set(old.subarray(0, Math.min(old.length, newLength)));\r\n    return resized;\r\n};","import { Config } from './core/config';\r\nimport { PointsAnimation } from './core/points-animation';\r\nimport { JavaScriptPhysics } from './core/pure-javascipt/physics';\r\nimport { JavascriptCanvasRenderer } from './core/pure-javascipt/renderer';\r\nimport { CanvasRenderingType } from './core/types';\r\n\r\n\r\nfunction main() {\r\n    const pointsCountInput = document.getElementById(Config.pointsCountInputId) as HTMLInputElement;\r\n    const fpsOutput = document.getElementById(Config.fpsOutputBlockId) as HTMLElement;\r\n    const pointsSizeChangeInput = document.getElementById(Config.pointsSizeInput) as HTMLInputElement;\r\n    const canvasElement = document.getElementById(Config.canvasElementId) as HTMLCanvasElement\r\n    const physicsJavaScriptEngine = new JavaScriptPhysics();\r\n    const javascriptCanvasRenderer = new JavascriptCanvasRenderer(canvasElement);\r\n\r\n    const pointsAnimation = new PointsAnimation(\r\n        physicsJavaScriptEngine,\r\n        javascriptCanvasRenderer, \r\n        CanvasRenderingType.Usual,\r\n        canvasElement, \r\n        pointsCountInput,\r\n        fpsOutput,\r\n        pointsSizeChangeInput\r\n    );\r\n\r\n    pointsAnimation.setupHandlers();\r\n    pointsAnimation.startListening();\r\n}\r\n\r\nmain();","import { type Renderer, type Dimension } from '../types';\r\n\r\n\r\nexport class JavascriptCanvasRenderer implements Renderer {\r\n    private pointSize = 3;\r\n    private readonly context: CanvasRenderingContext2D;\r\n    public constructor(private readonly canvasRef: HTMLCanvasElement) {\r\n        const ctx = canvasRef.getContext('2d');\r\n\r\n        if (!ctx) {\r\n            console.error('[App]: Can not get context from canvas ', canvasRef);\r\n            throw Error();\r\n        }\r\n\r\n        this.context = ctx;\r\n    }\r\n\r\n\r\n    public render(data: Float32Array, pointsAmount: number, size: Dimension): void {\r\n        this.context.fillStyle = 'white';\r\n        this.context.strokeStyle = 'white';\r\n\r\n        this.context.clearRect(\r\n            0,\r\n            0,\r\n            size.width,\r\n            size.height\r\n        );\r\n\r\n\r\n        this.context.beginPath();\r\n\r\n        for (let pointer = 0; pointer < pointsAmount * 4; pointer += 4) {\r\n            this.context.rect(\r\n                data[pointer + 0] - 1,\r\n                data[pointer + 1] - 1,\r\n                this.pointSize,\r\n                this.pointSize\r\n            );\r\n        }\r\n\r\n        this.context.fill();\r\n        this.context.stroke();\r\n        //this.context.closePath();\r\n    }\r\n\r\n    public setPointSize(size: number) {\r\n        this.pointSize = size;\r\n    }\r\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$ff5f6b9319289f6f$export$29cd7b75162a9425","freeze","canvasElementId","pointsCountInputId","fpsOutputBlockId","pointsSizeInput","$1743825ea9f69f1e$export$ff7672a891328c06","$4D3px","$3V8rW","physics","renderer","renderingtType","canvasElement","pointsCountInput","fpsOutput","pointsSizeChangeInput","pointsCount","canvasSize","width","height","handlePointSizeChange","event","setPointSize","Number","currentTarget","value","handleInput","parsed","handleClick","clickCoordinate","CanvasRenderingType","Usual","getClickCoordinatesForUsualCanvas","getClickCoordinatesForWebGLCanvas","run","validateHTML","startListening","lastTs","framesDrawn","frame","timestamp","window","requestAnimationFrame","tick","render","data","innerText","toFixed","setupHandlers","clientWidth","clientHeight","addEventListener","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","centerX","centerY","console","log","HTMLCanvasElement","error","Config","HTMLInputElement","HTMLElement","$5d5d0272ed9319df$export$2d515545fb3e062b","$c64c57661656c421$export$219fb17ee3299b7a","$mDWTX","Acceleration","PI_2","Math","PI","points","Float32Array","resizeF32Array","pointer","length","startX","startY","amplitude","sqrt","random","angle","cos","sin","$df5bef30413a053b$export$f4d452a2285a5605","old","newLength","resized","subarray","min","$fypJ4","$aP3eO","$5deae40f139f9cfd$export$f4a15f06a29916b5","canvasRef","pointSize","ctx","getContext","context","pointsAmount","size","fillStyle","strokeStyle","clearRect","beginPath","fill","stroke","$91f00a93702e8c6b$var$main","document","getElementById","physicsJavaScriptEngine","JavaScriptPhysics","javascriptCanvasRenderer","pointsAnimation","PointsAnimation"],"version":3,"file":"javascript.834ca6e7.js.map"}